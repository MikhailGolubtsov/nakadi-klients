package org.zalando.nakadi.client.scala.model

import com.fasterxml.jackson.annotation.JsonProperty
import scala.collection.JavaConversions._
import com.fasterxml.jackson.module.scala.JsonScalaEnumeration
import com.fasterxml.jackson.core.`type`.TypeReference

//object EventType {
//  def apply(
//    name: String, //
//    owningApplication: String, //
//    category: EventTypeCategory.Value, //
//    enrichmentStrategies: Seq[EventEnrichmentStrategy.Value], //
//    partitionStrategy: Option[PartitionStrategy.Value], //
//    schema: EventTypeSchema, //
//    dataKeyFields: Seq[String], //
//    partitionKeyFields: Seq[String], //
//    statistics: Option[EventTypeStatistics]) = new EventType(
//    name, //
//    owningApplication, //
//    category, //
//    enrichmentStrategies, //
//    partitionStrategy, //
//    schema, //
//    dataKeyFields, //
//    partitionKeyFields, //
//    statistics,
//    None)
//}

// Updated untill commit 57cace5

/**
 * The Event definition will be externalized in future versions of this document.
 * A basic payload of an Event. The actual schema is dependent on the information configured for the
 * EventType, as is its enforcement (see POST /event-types). Setting of metadata properties are
 * dependent on the configured enrichment as well.
 * For explanation on default configurations of validation and enrichment, see documentation of
 * `EventType.type`.
 * For concrete examples of what will be enforced by Nakadi see the objects BusinessEvent and
 * DataChangeEvent below.
 * @param eventType
 * @param additionalProperties Default value is true
 * @param title
 */
trait Event {}

/**
 * @param partition Id of the partition pointed to by this cursor.
 * @param offset Offset of the event being pointed to.
 */
case class Cursor(partition: String, offset: String)

/**
 *
 * Metadata for this Event. Contains commons fields for both Business and DataChange Events. Most are enriched by Nakadi upon reception, but they in general MIGHT be set by the client.
 * @param eid Identifier of this Event. Clients are allowed to generate this and this SHOULD be guaranteed to be unique from the perspective of the producer. Consumers MIGHT use this value to assert uniqueness of reception of the Event.
 * @param eventType The EventType of this Event. This is enriched by Nakadi on reception of the Event based on the endpoint where the Producer sent the Event to. If provided MUST match the endpoint. Failure to do so will cause rejection of the Event.
 * @param occurredAt Timestamp of creation of the Event generated by the producer.
 * @param receivedAt Timestamp of the reception of the Event by Nakadi. This is enriched upon reception of the Event. If set by the producer Event will be rejected.
 * @param parentEids Event identifier of the Event that caused the generation of this Event. Set by the producer.
 * @param flowId The flow-id of the producer of this Event. As this is usually a HTTP header, this is enriched from the header into the metadata by Nakadi to avoid clients having to explicitly copy this.
 * @param metadata This Metadata contains common fields unrelated to Nakadi logic. Should be mainly enriched by the Consumer.
 *
 */
case class EventMetadata(eid: String,
                         @JsonProperty("event_type") eventTypeName: Option[String],
                         occurredAt: String,
                         receivedAt: Option[String],
                         parentEids: Seq[String],
                         flowId: Option[String],
                         partition: Option[String])

/**
 * A Business Event. Usually represents a status transition in a Business process.
 *
 */
trait BusinessEvent extends Event {
  def metadata(): Option[EventMetadata]
}

/**
 * Indicators of a `DataChangeEvent`'s referred data type and the type of operations done on them.
 * @param dataType The datatype of the `DataChangeEvent`.
 * @param dataOperation The type of operation executed on the entity. * C: Creation * U: Update * D: Deletion * S: Snapshot
 */
trait DataChangeEventQualifier {
  def dataType(): String
  def dataOperation(): DataOperation.Value
}

/**
 * A Data change Event. Represents a change on a resource.
 *
 * @param data The payload of the type
 * @param eventQualifier Indicators of a `DataChangeEvent`'s referred data type and the type of operations done on them.
 * @param metadata Metadata for this Event. Contains commons fields for both Business and DataChange Events. Most are enriched by Nakadi upon reception, but they in general MIGHT be set by the client
 */
case class DataChangeEvent[T](
  data: T,
  dataType: String,
  @JsonProperty("data_op")@JsonScalaEnumeration(classOf[DataOperationType]) dataOperation: DataOperation.Value,
  metadata: Option[EventMetadata])
    extends DataChangeEventQualifier
    with Event

/**
 * @ param problemType An absolute URI that identifies the problem type. When dereferenced, it SHOULD provide human-readable API documentation for the problem type (e.g., using HTML). This Problem object is the same as provided by https://github.com/zalando/problem
 * @ param title A short, summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized)
 * @ param status The HTTP status code generated by the origin server for this occurrence of the problem.
 * @ param detail A human readable explanation specific to this occurrence of the problem.
 * @ param instance An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
 */
case class Problem(@JsonProperty("type") problemType: String,
                   title: String,
                   status: Integer,
                   detail: Option[String],
                   instance: Option[String])

case class Metrics(version: String, gauges: Map[String, Any])

/**
 * Partition information. Can be helpful when trying to start a stream using an unmanaged API. This information is not related to the state of the consumer clients.
 * @param  partition The partition's id.
 * @param  oldestAvailableOffset An offset of the oldest available Event in that partition. This value will be changing upon removal of Events from the partition by the background archiving/cleanup mechanism.
 * @param  newestAvailableOffset An offset of the newest available Event in that partition. This value will be changing upon reception of new events for this partition by Nakadi. This value can be used to construct a cursor when opening streams (see `GET /event-type/{name}/events` for details). Might assume the special name BEGIN, meaning a pointer to the offset of the oldest available event in the partition.
 */
case class Partition(partition: String, oldestAvailableOffset: String, newestAvailableOffset: String)

/**
 * One chunk of events in a stream. A batch consists of an array of `Event`s plus a `Cursor` pointing to the offset of the last Event in the stream. The size of the array of Event is limited by the parameters used to initialize a Stream. If acting as a keep alive message (see `GET /event-type/{name}/events`) the events array will be omitted. Sequential batches might repeat the cursor if no new events arrive.
 * @param cursor The cursor point to an event in the stream.
 * @param events The Event definition will be externalized in future versions of this document. A basic payload of an Event. The actual schema is dependent on the information configured for the EventType, as is its enforcement (see POST /event-types). Setting of metadata properties are dependent on the configured enrichment as well. For explanation on default configurations of validation and enrichment, see documentation of `EventType.type`. For concrete examples of what will be enforced by Nakadi see the objects
 * sEvent and DataChangeEvent below.
 */
case class EventStreamBatch[T <: Event](cursor: Cursor, events: Option[Seq[T]])

/**
 * An event type defines the schema and its runtime properties.
 * @param name Name of this EventType. Encodes the owner/responsible for this EventType.
 * @param owningApplication Indicator of the Application owning this `EventType`.
 * @param category Defines the category of this EventType.
 * @param enrichmentStrategies Determines the enrichment to be performed on an Event upon reception.
 * @param partitionStrategy Determines how the assignment of the event to a Partition should be handled.
 * @param schema The schema for this EventType.
 * @param dataKeyFields Indicators of the path of the properties that constitute the primary key (identifier) of the data within this Event.
 * @param partitionKeyFields Indicator of the field used for guaranteeing the ordering of Events of this type (used by the PartitionResolutionStrategy).
 * @param statistics Statistics of this EventType used for optimization purposes.
 *
 */
case class EventType(
  name: String,
  owningApplication: String,
  @JsonScalaEnumeration(classOf[EventTypeCategoryType]) category: EventTypeCategory.Value,
  @JsonScalaEnumeration(classOf[EventEnrichmentStrategyType]) enrichmentStrategies: Seq[EventEnrichmentStrategy.Value],
  @JsonScalaEnumeration(classOf[PartitionStrategyType]) partitionStrategy: Option[PartitionStrategy.Value],
  schema: EventTypeSchema,
  dataKeyFields: Seq[String],
  partitionKeyFields: Seq[String],
  @JsonProperty("default_statistic") statistics: Option[EventTypeStatistics]
  //@JsonScalaEnumeration(classOf[CompatibilityModeType]) compatibilityMode: Option[CompatibilityMode.Value]
  )/*{
  def this(
    name: String, //
    owningApplication: String, //
    category: EventTypeCategory.Value, //
    enrichmentStrategies: Seq[EventEnrichmentStrategy.Value], //
    partitionStrategy: Option[PartitionStrategy.Value], //
    schema: EventTypeSchema, //
    dataKeyFields: Seq[String], //
    partitionKeyFields: Seq[String], //
    statistics: Option[EventTypeStatistics]) = this(
    name, //
    owningApplication, //
    category, //
    enrichmentStrategies, //
    partitionStrategy, //
    schema, //
    dataKeyFields, //
    partitionKeyFields, //
    statistics,
    None)
}*/

/**
 * The schema for an EventType, expected to be a json schema in yaml
 * format (other formats might be added in the future).
 * @param schemaType The type of schema definition (avro, json-schema, etc).
 * @param schema The schema as string in the syntax defined in the field type.
 * Failure to respect the syntax will fail any operation on an EventType.
 */
case class EventTypeSchema(
  @JsonProperty("type")@JsonScalaEnumeration(classOf[SchemaTypeType]) schemaType: SchemaType.Value,
  schema: String)

/**
 * Operational statistics for an EventType. This data is generated by Nakadi
 * based on the runtime and might be used to guide changes in internal parameters.
 * @param messagesPerMinute - Write rate for events of this EventType. This rate encompasses all producers of this EventType for a Nakadi cluster. Measured in kb/minutes.
 * @param messageSize - Average message size for each Event of this EventType. Includes in the count the whole serialized form of the event, including metadata. Measured in bytes.
 * @param readParallelism - Amount of parallel readers (consumers) to this EventType.
 * @param writeParallelism - Amount of parallel writers (producers) to this EventType.
 *
 */
case class EventTypeStatistics(messagesPerMinute: Integer,
                               messageSize: Integer,
                               readParallelism: Integer,
                               writeParallelism: Integer)

/**
 * A status corresponding to one individual Event's publishing attempt.
 * @param eid Eid of the corresponding item. Will be absent if missing on the incoming Event.
 * @param publishingStatus Indicator of the submission of the Event within a Batch. - SUBMITTED indicates successful submission, including commit on he underlying broker. - FAILED indicates the message submission was not possible and can be resubmitted if so desired. - ABORTED indicates that the submission of this item was not attempted any further due to a failure on another item in the batch.
 * @param step Indicator of the step in the publishing process this Event reached. In Items that FAILED means the step of the failure. - NONE indicates that nothing was yet attempted for the publishing of this Event. Should be present only in the case of aborting the publishing during the validation of another (previous) Event. - VALIDATING, ENRICHING, PARTITIONING and PUBLISHING indicate all the corresponding steps of the publishing process.
 * @param detail Human readable information about the failure on this item. Items that are not SUBMITTED should have a description.
 *
 */
case class BatchItemResponse(
  eid: Option[String],
  @JsonScalaEnumeration(classOf[BatchItemPublishingStatusType]) publishingStatus: BatchItemPublishingStatus.Value,
  @JsonScalaEnumeration(classOf[BatchItemStepType]) step: Option[BatchItemStep.Value],
  detail: Option[String])

/////////////////////////////////
// ENUMS ////////////////////////
/////////////////////////////////

/**
 * Defines a rule for the resolution of incoming Events into partitions. Rules might require additional parameters; see the `doc` field of the existing rules for details. See `GET /registry/partition-strategies` for a list of available rules.
 */
case object PartitionStrategy extends Enumeration {
  type PartitionStrategy = Value
  val HASH = Value("hash")
  val USER_DEFINED = Value("user_defined")
  val RANDOM = Value("random")
}
class PartitionStrategyType extends TypeReference[PartitionStrategy.type]

/**
 * Defines a rule for transformation of an incoming Event. No existing fields might be modified. In practice this is used to set automatically values in the Event upon reception (i.e. set a reception timestamp on the Event). Rules might require additional parameters; see the `doc` field of the existing rules for details. See GET /registry/enrichment-strategies for a list of available rules.
 */
case object EventEnrichmentStrategy extends Enumeration {
  type EventEnrichmentStrategy = Value
  val METADATA = Value("metadata_enrichment")
}
class EventEnrichmentStrategyType extends TypeReference[EventEnrichmentStrategy.type]

/**
 * Identifier for the type of operation to executed on the entity. <br>
 * C: Creation <br>
 * U: Update <br>
 * D: Deletion <br>
 * S: Snapshot <br> <br>
 * Values = CREATE("C"), UPDATE("U"), DELETE("D"), SNAPSHOT("S")
 */
case object DataOperation extends Enumeration {
  type DataOperation = Value
  val CREATE = Value("C")
  val UPDATE = Value("U")
  val DELETE = Value("D")
  val SNAPSHOT = Value("S")

}
class DataOperationType extends TypeReference[DataOperation.type]

/**
 * Defines the category of an EventType. <br>
 * Values = UNDEFINED("undefined") DATA("data") BUSINESS("business")
 */
case object EventTypeCategory extends Enumeration {
  type EventTypeCategory = Value
  val UNDEFINED = Value("undefined")
  val DATA = Value("data")
  val BUSINESS = Value("business")

}
class EventTypeCategoryType extends TypeReference[EventTypeCategory.type]

/**
 * Indicator of the submission of the Event within a Batch. <br>
 * - SUBMITTED indicates successful submission, including commit on he underlying broker.<br>
 * - FAILED indicates the message submission was not possible and can be resubmitted if so desired.<br>
 * - ABORTED indicates that the submission of this item was not attempted any further due to a failure
 * on another item in the batch.<br> <br>
 * Values = SUBMITTED("SUBMITTED") FAILED("FAILED") ABORTED("ABORTED")
 */
case object BatchItemPublishingStatus extends Enumeration {
  type BatchItemPublishingStatus = Value
  val SUBMITTED = Value("submitted")
  val FAILED = Value("failed")
  val ABORTED = Value("aborted")
}

class BatchItemPublishingStatusType extends TypeReference[BatchItemPublishingStatus.type]

/**
 * Indicator of the step in the pulbishing process this Event reached.
 * In Items that FAILED means the step of the failure.
 * - NONE indicates that nothing was yet attempted for the publishing of this Event. Should be present
 * only in the case of aborting the publishing during the validation of another (previous) Event. <br>
 * - VALIDATING, ENRICHING, PARTITIONING and PUBLISHING indicate all the corresponding steps of the
 * publishing process. <br> <br>
 * Values = NONE("none"), VALIDATING("validating"), ENRICHING("enriching"), PARTITIONING("partitioning"), PUBLISHING("publishing")
 */
case object BatchItemStep extends Enumeration {
  type BatchItemStep = Value
  val NONE = Value("none")
  val VALIDATING = Value("validating")
  val ENRICHING = Value("enriching")
  val PARTITIONING = Value("partitioning")
  val PUBLISHING = Value("publishing")

}
class BatchItemStepType extends TypeReference[BatchItemStep.type]

case object SchemaType extends Enumeration {
  type SchemaType = Value
  val JSON = Value("json_schema")
}
class SchemaTypeType extends TypeReference[SchemaType.type]

/**
 * Compatibility mode provides a mean for event owners to evolve their schema, given changes respect the
 * semantics defined by this field. <br>
 * It's designed to be flexible enough so that producers can evolve their schemas while not
 * inadvertently breaking existent consumers.<br>
 * Once defined, the compatibility mode is fixed, since otherwise it would break a predefined contract,
 * declared by the producer. <br>
 *  - FIXED - Schema changes are not allowed. This is used only by legacy event types. This option is not
 * available for new event types. Schema validation is lenient and allow fields that are not defined. Also,
 * it's possible to use the full json schema specification for defining schemas.
 *  - NONE - Any schema modification is accepted, even if it might break existing producers or consumers. When
 * validating events, no additional properties are accepted unless explicitly stated in the schema.
 *  - COMPATIBLE (default) - Consumers can reliably parse events produced under different versions. Every event published
 * since the first version is still valid based on the newest schema. When in compatible mode, it's allowed to
 * add new optional properties and definitions to an existing schema, but no other changes are allowed.
 * Under this mode, the following json-schema attributes are not supported: `not`, `patternProperties`,
 * `additionalProperties` and `additionalItems`. When validating events, additional properties is `false`.
 */
case object CompatibilityMode extends Enumeration {
  type CompatibilityMode = Value
  val FIXED = Value("fixed")
  val NONE = Value("none")
  val COMPATIBLE = Value("compatible")
}
class CompatibilityModeType extends TypeReference[CompatibilityMode.type]

