package org.zalando.nakadi.client.model

/**
 * The Event definition will be externalized in future versions of this document.
 * A basic payload of an Event. The actual schema is dependent on the information configured for the
 * EventType, as is its enforcement (see POST /event-types). Setting of metadata properties are
 * dependent on the configured enrichment as well.
 * For explanation on default configurations of validation and enrichment, see documentation of
 * `EventType.type`.
 * For concrete examples of what will be enforced by Nakadi see the objects BusinessEvent and
 * DataChangeEvent below.
 * @param eventType
 * @param additionalProperties Default value is true
 * @param title
 */
case class Event(
  eventType: EventType,
  additionalProperties: Boolean,
  title: String)

/**
 * Metadata for this Event. Contains commons fields for both Business and DataChange Events. Most are enriched by Nakadi upon reception, but they in general MIGHT be set by the client.
 * @param eid Identifier of this Event. Clients are allowed to generate this and this SHOULD be guaranteed to be unique from the perspective of the producer. Consumers MIGHT use this value to assert uniqueness of reception of the Event.
 * @param eventType The EventType of this Event. This is enriched by Nakadi on reception of the Event based on the endpoint where the Producer sent the Event to. If provided MUST match the endpoint. Failure to do so will cause rejection of the Event.
 * @param occurredAt Timestamp of creation of the Event generated by the producer.
 * @param receivedAt Timestamp of the reception of the Event by Nakadi. This is enriched upon reception of the Event. If set by the producer Event will be rejected.
 * @param parentEids Event identifier of the Event that caused the generation of this Event. Set by the producer.
 * @param flowId The flow-id of the producer of this Event. As this is usually a HTTP header, this is enriched from the header into the metadata by Nakadi to avoid clients having to explicitly copy this.
 * @param metadata This Metadata contains common fields unrelated to Nakadi logic. Should be mainly enriched by the Consumer.
 *
 */
case class EventMetadata(
  eid: String,
  eventType: String,
  occurredAt: String,
  receivedAt: String,
  parentEids: Seq[String],
  flowId: String,
  metadata: Map[String, Any])

/**
 * A Business Event. Usually represents a status transition in a Business process.
 *
 * @param metadata Metadata for this Event. Contains commons fields for both Business and DataChange Events. Most are enriched by Nakadi upon reception, but they in general MIGHT be set by the client.
 */
case class BusinessEvent(metadata: EventMetadata)

/**
 * Indicators of a `DataChangeEvent`'s referred data type and the type of operations done on them.
 * @param dataType The datatype of the `DataChangeEvent`.
 * @param dataOp The type of operation executed on the entity. * C: Creation * U: Update * D: Deletion * S: Snapshot
 */
case class DataChangeEventQualifier(
  dataType: String,
  dataOperation: DataOperation.Value)

/**
 * A Data change Event. Represents a change on a resource.
 *
 * @param data The payload of the type
 * @param eventQualifier Indicators of a `DataChangeEvent`'s referred data type and the type of operations done on them.
 * @param metadata Metadata for this Event. Contains commons fields for both Business and DataChange Events. Most are enriched by Nakadi upon reception, but they in general MIGHT be set by the client
 */
case class DataChangeEvent[T](
  data: T,
  eventQualifier: DataChangeEventQualifier,
  metadata: EventMetadata)

/**
 * @ param problemType An absolute URI that identifies the problem type. When dereferenced, it SHOULD provide human-readable API documentation for the problem type (e.g., using HTML). This Problem object is the same as provided by https://github.com/zalando/problem
 * @ param title A short, summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized)
 * @ param status The HTTP status code generated by the origin server for this occurrence of the problem.
 * @ param detail A human readable explanation specific to this occurrence of the problem.
 * @ param instance An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
 */
case class Problem(
  problemType: String,
  title: String,
  status: Int,
  detail: String,
  instance: String)

case class Metrics(metrics: String) //TODO: It is not defined yet!

/**
 * Partition information. Can be helpful when trying to start a stream using an unmanaged API. This information is not related to the state of the consumer clients.
 * @param  partition The partition's id.
 * @param  oldestAvailableOffset An offset of the oldest available Event in that partition. This value will be changing upon removal of Events from the partition by the background archiving/cleanup mechanism.
 * @param  newestAvailableOffset An offset of the newest available Event in that partition. This value will be changing upon reception of new events for this partition by Nakadi. This value can be used to construct a cursor when opening streams (see `GET /event-type/{name}/events` for details). Might assume the special name BEGIN, meaning a pointer to the offset of the oldest available event in the partition.
 */
case class Partition(
  partition: String,
  oldestAvailableOffset: String,
  newestAvailableOffset: String)
/**
 * @param partition Id of the partition pointed to by this cursor.
 * @param offset Offset of the event being pointed to.
 */
case class Cursor(
  partition: String,
  offset: String)

/**
 * One chunk of events in a stream. A batch consists of an array of `Event`s plus a `Cursor` pointing to the offset of the last Event in the stream. The size of the array of Event is limited by the parameters used to initialize a Stream. If acting as a keep alive message (see `GET /event-type/{name}/events`) the events array will be omitted. Sequential batches might repeat the cursor if no new events arrive.
 * @param cursor The cursor point to an event in the stream.
 * @param events The Event definition will be externalized in future versions of this document. A basic payload of an Event. The actual schema is dependent on the information configured for the EventType, as is its enforcement (see POST /event-types). Setting of metadata properties are dependent on the configured enrichment as well. For explanation on default configurations of validation and enrichment, see documentation of `EventType.type`. For concrete examples of what will be enforced by Nakadi see the objects BusinessEvent and DataChangeEvent below.
 */
case class EventStreamBatch(
  cursor: Cursor,
  events: Seq[Event])

/**
 * An event type defines the schema and its runtime properties.
 * @param name Name of this EventType. Encodes the owner/responsible for this EventType. The name for the EventType SHOULD follow the pattern, but is not enforced 'stups_owning_application.event-type', for example 'gizig.price-change'. The components of the name are: * Organization: the organizational unit where the team is located; can be omitted. * Team name: name of the team responsible for owning application; can be omitted. * Owning application: SHOULD match the field owning_application; indicates * EventType name: name of this EventType; SHOULD end in ChangeEvent for DataChangeEvents; MUST be in the past tense for BusinessEvents. (TBD: how to deal with organizational changes? Should be reflected on the name of the EventType? Isn't it better to omit [organization:team] completely?)
 * @param owner Indicator of the Application owning this `EventType`.
 * @param category Defines the category of this EventType. The value set will influence, if not set otherwise, the default set of validation-strategies, enrichment-strategies, and the effective_schema in the following way: - `undefined`: No predefined changes apply. `effective_schema` is exactly the same as the `EventTypeSchema`. Default validation_strategy for this `EventType` is `[{name: 'schema-validation'}]`. - `data`: Events of this category will be DataChangeEvents. `effective_schema` contains `metadata`, and adds fields `data_op` and `data_type`. The passed EventTypeSchema defines the schema of `data`. Default validation_strategy for this `EventType` is `[{name: 'datachange-schema-validation'}]`. - `business`: Events of this category will be BusinessEvents. `effective_schema` contains `metadata` and any additionally defined properties passed in the `EventTypeSchema` directly on top level of the Event. If name conflicts arise, creation of this EventType will be rejected. Default validation_strategy for this `EventType` is `[{name: 'schema-validation'}]`.
 * @param effectiveSchema The effective schema of this `EventType`. The predefined schema validator will use the value of this field as base for the validation. The creation of EventTypes of different categories implies a distinct general structure for the payload of events of each type. This ultimate format the payload must adhere to is reflected in the `effective_schema`. See description of field `category` for more details of its generation. This field is informative and its contents cannot be manipulated directly.
 * @param validationStrategies Determines the validation that has to be executed upon reception of Events of this type. Events are rejected if any of the rules fail (see details of Problem response on the Event publishing methods). Rule evaluation order is the same as in this array. If not explicitly set, default value will respect the definition of the `EventType.category`.
 * @param enrichmentStrategies Determines the enrichment to be performed on an Event upon reception. Enrichment is performed once upon reception (and after validation) of an Event and is only possible on fields that are not defined on the incoming Event. See documentation for the write operation for details on behaviour in case of unsuccessful enrichment.
 * @param partitionResolutionStrategy Determines how the assignment of the event to a Partition should be handled.
 * @param schema The schema for this EventType. This is expected to be a json schema in yaml format (other formats might be added in the future).
 * @param dataKeyFields Indicators of the path of the properties that constitute the primary key (identifier) of the data within this Event. If set MUST be a valid required field as defined in the schema. (TBD should be required? Is applicable only to both Business and DataChange Events?)
 * @param partitioningKeyFields Indicator of the field used for guaranteeing the ordering of Events of this type (used by the PartitionResolutionStrategy). If set MUST be a valid required field as defined in the schema.
 *
 */
case class EventType(
  name: String,
  owner: String,
  category: String,
  effectiveSchema: String,
  validationStrategies: Seq[String],
  enrichmentStrategies: Seq[String],
  partitionResolutionStrategy: PartitionResolutionStrategy, //Different naming
  schema: EventTypeSchema,
  dataKeyFields: Seq[String],
  partitioningKeyFields: Seq[String])

/**
 * The schema for an EventType, expected to be a json schema in yaml format (other formats might be added in the future).
 * @param type The type of schema definition (avro, json-schema, etc).
 * @param schema The schema as string in the syntax defined in the field type. Failure to respect the syntax will fail any operation on an EventType.
 */
case class EventTypeSchema(
  schemaType: String,
  schema: String)

/**
 * Defines a rule for validation of an incoming Event. Rules might require additional parameters; see the `doc` field of the existing rules for details. See GET /registry/validation-strategies for a list of available rules.
 * @param name Name of the strategy.
 * @param doc Documentation for the validation.
 */
case class EventValidationStrategy(
  name: String,
  doc: String)

/**
 * Defines a rule for the resolution of incoming Events into partitions. Rules might require additional parameters; see the `doc` field of the existing rules for details. See `GET /registry/partition-strategies` for a list of available rules.
 * @param name Name of the strategy.
 * @param doc Documentation for the partition resolution.
 */
case class PartitionResolutionStrategy(
  name: String,
  doc: String)

/**
 * Defines a rule for transformation of an incoming Event. No existing fields might be modified. In practice this is used to set automatically values in the Event upon reception (i.e. set a reception timestamp on the Event). Rules might require additional parameters; see the `doc` field of the existing rules for details. See GET /registry/enrichment-strategies for a list of available rules.
 * @param name Name of the strategy.
 * @param doc Documentation for the enrichment.
 */
case class EventEnrichmentStrategy(
  name: String,
  doc: String)

/**
 * Identifier for the type of operation when conducting an Entity.
 * @param CREATE
 * @param UPDATE
 * @param DELETE
 * @param SNAPSHOT
 */
case object DataOperation extends Enumeration {
  type DataOperation = Value
  val CREATE = Value("C")
  val UPDATE = Value("U")
  val DELETE = Value("D")
  val SNAPSHOT = Value("S")

}

 